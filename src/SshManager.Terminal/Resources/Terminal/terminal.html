<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSH Terminal</title>
    <!--
        SECURITY: CDN resources use Subresource Integrity (SRI) to prevent supply chain attacks.
        SRI hashes were generated using: https://www.srihash.org/

        To update these hashes when upgrading xterm.js:
        1. Visit https://www.srihash.org/
        2. Enter the CDN URL for each resource
        3. Copy the generated integrity hash
        4. Update the integrity attribute below

        Alternative: Use openssl to generate SRI hash locally:
        $ curl -s https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css | openssl dgst -sha384 -binary | openssl base64 -A
    -->
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css"
          integrity="sha384-8Xk9wy/gzEDUKrXtrmCFa2bBuK3BpjpDuL/p0SeKQX19Khl/M+lHOgD/CyYf7efP"
          crossorigin="anonymous">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        #terminal-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            padding: 0;
            background-color: #1e1e1e;
        }

        @font-face {
            font-family: 'Source Code Pro Powerline';
            src: url('data:font/otf;base64,{{POWERLINE_SCP_REGULAR}}') format('opentype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Source Code Pro Powerline';
            src: url('data:font/otf;base64,{{POWERLINE_SCP_BOLD}}') format('opentype');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Source Code Pro Powerline';
            src: url('data:font/otf;base64,{{POWERLINE_SCP_ITALIC}}') format('opentype');
            font-weight: 400;
            font-style: italic;
            font-display: swap;
        }

        @font-face {
            font-family: 'Source Code Pro Powerline';
            src: url('data:font/otf;base64,{{POWERLINE_SCP_BOLDITALIC}}') format('opentype');
            font-weight: 700;
            font-style: italic;
            font-display: swap;
        }

        /* Hide scrollbars on the terminal viewport */
        .xterm-viewport::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .xterm-viewport {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        /* Ensure terminal fills container */
        .xterm {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal-container"></div>
    <!--
        SECURITY: Script tags include SRI integrity hashes to verify CDN content hasn't been tampered with.
        The crossorigin="anonymous" attribute is required for SRI to work with cross-origin resources.
    -->
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"
            integrity="sha384-M169f14mRZOXm3hD/v2Ti0ThIT/RnAQagXA9nlE15yHAtrW19gdePJh/HaTzUOe/"
            crossorigin="anonymous"
            onerror="console.error('Failed to load xterm.js from CDN'); document.body.innerHTML='<p style=color:red>ERROR: Failed to load xterm.js. Check network/firewall.</p>';"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"
            integrity="sha384-iF+jqbuti4XlB64clWgFWYEscb+UnSRv3VgVikGYZu+otNFnSHr7y7NcKfBnGizn"
            crossorigin="anonymous"
            onerror="console.error('Failed to load xterm addon-fit from CDN');"></script>
    <script>
        (function() {
            'use strict';

            let terminal = null;
            let fitAddon = null;
            let resizeTimeout = null;
            let resizeObserver = null;
            const RESIZE_DEBOUNCE_MS = 100;

            // Initialize terminal when DOM is ready
            function init() {
                console.log('Terminal init() called');

                // Check if xterm.js loaded successfully
                if (typeof Terminal === 'undefined') {
                    console.error('xterm.js Terminal class not available - CDN load may have failed');
                    document.body.innerHTML = '<p style="color:red;padding:20px;">ERROR: xterm.js failed to load. Check network connection and firewall settings.</p>';
                    return;
                }

                if (typeof FitAddon === 'undefined') {
                    console.error('xterm.js FitAddon not available - CDN load may have failed');
                    document.body.innerHTML = '<p style="color:red;padding:20px;">ERROR: xterm.js addon-fit failed to load. Check network connection.</p>';
                    return;
                }

                const container = document.getElementById('terminal-container');
                if (!container) {
                    console.error('Terminal container not found');
                    return;
                }

                console.log('Creating xterm.js Terminal instance');

                // Create terminal instance
                try {
                terminal = new Terminal({
                    cursorBlink: true,
                    cursorStyle: 'block',
                    fontSize: 14,
                    fontFamily: '"Source Code Pro Powerline", "Cascadia Mono", "Cascadia Code", "Consolas", "Courier New", monospace',
                    letterSpacing: 0,
                    lineHeight: 1.0,
                    allowTransparency: true,
                    scrollback: 10000,
                    // Disable bracketed paste mode to prevent ^[[200~ sequences on paste
                    // Some remote shells (especially in containers) don't handle these properly
                    bracketedPasteMode: false,
                    theme: {
                        background: '#1e1e1e',
                        foreground: '#d4d4d4',
                        cursor: '#d4d4d4',
                        selectionBackground: '#264f78',
                        black: '#000000',
                        red: '#cd3131',
                        green: '#0dbc79',
                        yellow: '#e5e510',
                        blue: '#2472c8',
                        magenta: '#bc3fbc',
                        cyan: '#11a8cd',
                        white: '#e5e5e5',
                        brightBlack: '#666666',
                        brightRed: '#f14c4c',
                        brightGreen: '#23d18b',
                        brightYellow: '#f5f543',
                        brightBlue: '#3b8eea',
                        brightMagenta: '#d670d6',
                        brightCyan: '#29b8db',
                        brightWhite: '#ffffff'
                    }
                });

                // Create and load fit addon
                fitAddon = new FitAddon.FitAddon();
                terminal.loadAddon(fitAddon);

                // Open terminal in container
                terminal.open(container);

                // Initial fit
                fitAddon.fit();
                scheduleFit();

                // Listen for user input
                terminal.onData(function(data) {
                    postMessageToHost({ type: 'input', data: data });
                });

                // Handle special keys that may not be forwarded properly by WebView2
                // Use document-level listener to catch keys before any component handling
                document.addEventListener('keydown', function(event) {
                    // Delete key sends escape sequence \x1b[3~
                    if (event.key === 'Delete' || event.keyCode === 46) {
                        postMessageToHost({ type: 'input', data: '\x1b[3~' });
                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    }
                    // Insert key sends escape sequence \x1b[2~
                    if (event.key === 'Insert' || event.keyCode === 45) {
                        postMessageToHost({ type: 'input', data: '\x1b[2~' });
                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    }
                }, true); // Use capture phase to get events first

                // Custom paste handler to bypass bracketed paste mode
                // Remote shells may enable bracketed paste (\e[?2004h) which causes
                // xterm.js to wrap pasted text in \e[200~...\e[201~ sequences.
                // Applications like nano don't handle these, showing ^[[200~ literally.
                // This handler intercepts paste and sends raw text directly.
                document.addEventListener('paste', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    var text = (event.clipboardData || window.clipboardData).getData('text');
                    if (text) {
                        // Normalize line endings: Windows clipboard uses \r\n,
                        // but terminals expect \r only. Without this, pasting
                        // multi-line text inserts extra blank lines/spaces.
                        text = text.replace(/\r\n/g, '\r').replace(/\n/g, '\r');
                        postMessageToHost({ type: 'input', data: text });
                    }
                }, true); // Use capture phase to intercept before xterm.js

                // Listen for terminal resize
                terminal.onResize(function(size) {
                    postMessageToHost({ type: 'resized', cols: size.cols, rows: size.rows });
                });

                // Setup message listener for C# communication
                setupMessageListener();

                // Handle window resize with debounce
                window.addEventListener('resize', handleWindowResize);

                // Observe container size changes (e.g., tab switches, pane resizes)
                if (window.ResizeObserver) {
                    resizeObserver = new ResizeObserver(function() {
                        scheduleFit();
                    });
                    resizeObserver.observe(container);
                }

                // Refit after fonts finish loading to avoid stale cell metrics
                if (document.fonts && document.fonts.ready) {
                    document.fonts.ready.then(function() {
                        scheduleFit();
                    });
                }

                // Send ready message
                console.log('Sending ready message to C#');
                postMessageToHost({ type: 'ready' });

                // Send initial size
                postMessageToHost({ type: 'resized', cols: terminal.cols, rows: terminal.rows });
                console.log('Terminal initialization complete');

                } catch (e) {
                    console.error('Error during terminal initialization:', e);
                    document.body.innerHTML = '<p style="color:red;padding:20px;">ERROR: Terminal initialization failed: ' + e.message + '</p>';
                }
            }

            // Debounced window resize handler
            function handleWindowResize() {
                scheduleFit();
            }

            function scheduleFit() {
                if (resizeTimeout) {
                    clearTimeout(resizeTimeout);
                }
                resizeTimeout = setTimeout(function() {
                    if (fitAddon && terminal) {
                        fitAddon.fit();
                    }
                }, RESIZE_DEBOUNCE_MS);
            }

            // Setup listener for messages from C#
            function setupMessageListener() {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.addEventListener('message', function(event) {
                        handleMessage(event.data);
                    });
                } else {
                    // Fallback for testing in browser
                    window.addEventListener('message', function(event) {
                        handleMessage(event.data);
                    });
                }
            }

            // Handle incoming messages from C#
            function handleMessage(message) {
                if (!message || !message.type) {
                    return;
                }

                switch (message.type) {
                    case 'write':
                        if (terminal && message.data) {
                            terminal.write(message.data);
                        }
                        break;

                    case 'resize':
                        if (terminal && typeof message.cols === 'number' && typeof message.rows === 'number') {
                            terminal.resize(message.cols, message.rows);
                        }
                        break;

                    case 'fit':
                        if (fitAddon && terminal) {
                            scheduleFit();
                        }
                        break;

                    case 'setTheme':
                        if (terminal && message.theme) {
                            terminal.options.theme = message.theme;
                        }
                        break;

                    case 'setFont':
                        if (terminal) {
                            if (message.fontFamily) {
                                terminal.options.fontFamily = message.fontFamily;
                            }
                            if (typeof message.fontSize === 'number') {
                                terminal.options.fontSize = message.fontSize;
                            }
                            if (fitAddon) {
                                fitAddon.fit();
                            }
                        }
                        break;

                    case 'focus':
                        if (terminal) {
                            terminal.focus();
                        }
                        break;

                    case 'clear':
                        if (terminal) {
                            terminal.clear();
                        }
                        break;

                    case 'setScrollback':
                        if (terminal && typeof message.scrollback === 'number') {
                            terminal.options.scrollback = message.scrollback;
                        }
                        break;

                    default:
                        console.warn('Unknown message type:', message.type);
                }
            }

            // Send message to C# host
            function postMessageToHost(message) {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage(message);
                } else {
                    // Fallback for testing - log to console
                    console.log('postMessage to host:', message);
                }
            }

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>
</html>
